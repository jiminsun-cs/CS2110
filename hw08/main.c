#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"


/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/start.h"
#include "images/candy_img.h"
#include "images/croc.h"
#include "images/background.h"
#include "images/win.h"
#include "images/lose.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};



int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT =  MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;


  // Load initial application state
  enum gba_state state = START;
  enum gba_state prevState = START;

   struct character character;
   UNUSED(character);
   struct candy candies_display[N_CANDIES];
   UNUSED(candies_display);

    //initialize character x,y position

    struct state curr, prev;
    struct candy *cc, *oc;
    UNUSED(curr);
    UNUSED(prev);
    UNUSED(cc);
    UNUSED(oc);

    curr.character.x = HEIGHT/2;
    curr.character.y = WIDTH/2;
    prev.character.x = HEIGHT/2;
    prev.character.y = WIDTH/2;

   int livesLeft = 1;
   int candiesEaten = 0;
   prev = curr;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    prev = curr;
    waitForVBlank();
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    switch (state) {
      case START: //start, press enter to begin
        waitForVBlank();
        drawFullScreenImageDMA(start);

            if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                prevState = START;
                state = PLAY;
                    for (int i = 0; i < N_CANDIES; i++) {
                        cc = &candies_display[i];
                        cc->x = randint(0, WIDTH + 160 - CANDY_WIDTH) % 160;
                        cc->y = randint(40, HEIGHT - CANDY_HEIGHT) % 240;
                    }

                 curr.character.x = WIDTH/2;
                 curr.character.y = HEIGHT/2;
               int livesLeft = 1;
               int candiesEaten = 0;
                 UNUSED(livesLeft);
                 UNUSED(candiesEaten);
                 UNUSED(prevState);
            }

        break;
      case PLAY:
      // reset game
          if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            livesLeft = 1;
            candiesEaten = 0;
            state = START;
          }
          //update separately

            if (curr.character.x <= 240 - CHAR_HEIGHT) {
                if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
                    prev.character.y = curr.character.y;
                    prev.character.x = curr.character.x;
                    curr.character.x += 10;
                }
            }
            if (curr.character.x >= 0) {
                if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
                    prev.character.y = curr.character.y;
                    prev.character.x = curr.character.x;
                    curr.character.x -= 10;
                }
            }
            if (curr.character.y >= 0) {
                if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
                    prev.character.x = curr.character.x;
                    prev.character.y = curr.character.y;
                    curr.character.y -= 10;
                }
            }
            if (curr.character.y <= 160 - CHAR_WIDTH) {
                if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
                    prev.character.x = curr.character.x;
                    prev.character.y = curr.character.y;
                    curr.character.y += 10;
                }
            }

            for (int i = 0; i < N_CANDIES; i++) {
            // 1) bottom candy < bottom character < top candy
            // OR
            // 2) bottom candy < top character < top candy
            //
            // AND
            //
            // 3) left candy < right character < right candy
            // Or
            // 4) left candy < left character < right candy


                // character.x = x coordinate of the screen
                // character.y = y coordinate of the screen

                int char_bottom = (curr.character.y + 10);
                int char_top = curr.character.y;
                int char_left = curr.character.x;
                int char_right = (curr.character.x + 10);

                int prev_char_bottom = (prev.character.y + 10);
                int prev_char_top = prev.character.y;
                int prev_char_left = prev.character.x;
                int prev_char_right = (prev.character.x + 10);

                int candy_bottom = (candies_display[i].y + 10);
                int candy_top = candies_display[i].y;
                int candy_left = candies_display[i].x;
                int candy_right = (candies_display[i].x + 10);


                if (
                    ( ((char_bottom <= candy_bottom) && (char_bottom >= candy_top)) || ((char_top <= candy_bottom) && (char_top >= candy_top)) )
                     &&
                    ( ((char_left >= candy_left) && (char_left <= candy_right)) ||  ((char_right >= candy_left) && ((char_right <= candy_right))) )
                ) {
                   if (
                       !(
                            ( ((prev_char_bottom <= candy_bottom) && (prev_char_bottom >= candy_top)) || ((prev_char_top <= candy_bottom) && (prev_char_top >= candy_top)) )
                             &&
                            ( ((prev_char_left >= candy_left) && (prev_char_left <= candy_right)) || ((prev_char_right >= candy_left) && (prev_char_right <= candy_right)))
                        )
                       ) {
                        candiesEaten += 1;
                        }
                    }
               }



            if (curr.character.x == WIDTH - CHAR_WIDTH || curr.character.y == HEIGHT - CHAR_HEIGHT || curr.character.x == 0 || curr.character.y == 0) {
                livesLeft -= 1;
            }

            if (candiesEaten >= 2) {
                state = WIN;
            }
            if (livesLeft == 0) {
                state = LOSE;
            }

            char buffer_candies[30];
            snprintf(buffer_candies, 30, "Eaten Candies: %d", candiesEaten);


            waitForVBlank();
            fillScreenDMA(BLACK);
            drawString(140, 30, buffer_candies, WHITE);

           for (int i = 0; i < N_CANDIES;  i++) {
            drawImageDMA(candies_display[i].y, candies_display[i].x, CANDY_WIDTH, CANDY_HEIGHT, candy_img);
           }
           drawImageDMA(curr.character.y, curr.character.x, CHAR_WIDTH, CHAR_HEIGHT, croc);



        break;
      case WIN:
        waitForVBlank();
        drawFullScreenImageDMA(win);
          if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            livesLeft = 1;
            candiesEaten = 0;
            state = START;
          }

        break;
      case LOSE:
        waitForVBlank();
        drawFullScreenImageDMA(lose);
          if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            livesLeft = 1;
            candiesEaten = 0;
            state = START;
          }

        break;

}
previousButtons = currentButtons;

    }

  }

